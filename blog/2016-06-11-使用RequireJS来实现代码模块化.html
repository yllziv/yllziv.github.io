<!doctype html><html class="theme-next pisces"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css" rel="stylesheet" type="text/css"><meta name="keywords" content="JavaScript,"><link rel="alternate" href="/rss.xml" title="ziv小站" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"><meta name="description" content="引言RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它是AMD规范最好的实现者之一，也可以用在Node环境中。 与传统方式对比传统方式123456789&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;script typ"><meta name="keywords" content="JavaScript"><meta property="og:type" content="article"><meta property="og:title" content="使用RequireJS来实现代码模块化"><meta property="og:url" content="http://yanglonglong.com/blog/2016-06-11-使用RequireJS来实现代码模块化.html"><meta property="og:site_name" content="ziv小站"><meta property="og:description" content="引言RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它是AMD规范最好的实现者之一，也可以用在Node环境中。 与传统方式对比传统方式123456789&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;script typ"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2016-07-04T12:24:52.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用RequireJS来实现代码模块化"><meta name="twitter:description" content="引言RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它是AMD规范最好的实现者之一，也可以用在Node环境中。 与传统方式对比传统方式123456789&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;    &amp;lt;head&amp;gt;        &amp;lt;script typ"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!1,duoshuo:{userId:0x56ab38cf59400400,author:"博主"}};!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];"https"===e?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}();var _hmt=_hmt||[];!function(){var t=document.createElement("script");t.src="//hm.baidu.com/hm.js?830d141512282f99a813d8a04a08afde";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><title> 使用RequireJS来实现代码模块化 | ziv小站</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-76641751-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?830d141512282f99a813d8a04a08afde";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ziv小站</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">杨龙龙的个人博客</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-home fa-fw"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-archive fa-fw"></i><br> 归档</a></li><li class="menu-item menu-item-life"><a href="/life" rel="section"><i class="menu-item-icon fa fa-life-ring fa-fw"></i><br> 生活</a></li><li class="menu-item menu-item-photos"><a href="/photos" rel="section"><i class="menu-item-icon fa fa-camera-retro fa-fw"></i><br> 相册</a></li><li class="menu-item menu-item-grid"><a href="/grid" rel="section"><i class="menu-item-icon fa fa-calendar fa-fw"></i><br> 格志</a></li><li class="menu-item menu-item-tool"><a href="/tool" rel="section"><i class="menu-item-icon fa fa-legal fa-fw"></i><br> 工具</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> 使用RequireJS来实现代码模块化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-06-11T00:00:34+08:00" content="2016-06-11">2016-06-11</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/web/" itemprop="url" rel="index"><span itemprop="name">web</span></a></span></span> <span id="/blog/2016-06-11-使用RequireJS来实现代码模块化.html" class="leancloud_visitors" data-flag-title="使用RequireJS来实现代码模块化">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>RequireJS的目标是鼓励代码的模块化，它使用了不同于传统script标签的脚本加载步骤。可以用它来加速、优化代码，但其主要目的还是为了代码的模块化。它是AMD规范最好的实现者之一，也可以用在Node环境中。</p><h2 id="与传统方式对比"><a href="#与传统方式对比" class="headerlink" title="与传统方式对比"></a>与传统方式对比</h2><h3 id="传统方式"><a href="#传统方式" class="headerlink" title="传统方式"></a>传统方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>body<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(<span class="string">"it works"</span>);</div><div class="line">&#125;</div><div class="line">fun1();</div></pre></td></tr></table></figure><p>或者使用了块作用域来申明function防止污染全局变量<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="string">"it works"</span>);</div><div class="line">    &#125;</div><div class="line">    fun1();</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><p></p><p>alert执行的时候，<span>body</span>并未被显示，当点击确定后，才出现，这就是JS阻塞浏览器渲染导致的结果。<br>由于JS文件存在依赖关系，比如上面的b.js要依赖于a.js,所以务必保证a.js优先引入到页面上来且先加载，要严格保证加载顺序，依赖性最大的文件一定要放到最后加载。</p><p>但是当依赖关系很复杂的时候，代码的编写和维护就会变得困难了。</p><h3 id="使用RequireJS模块加载"><a href="#使用RequireJS模块加载" class="headerlink" title="使用RequireJS模块加载"></a>使用RequireJS模块加载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">            <span class="built_in">require</span>([<span class="string">"a"</span>]);</div><div class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>body<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 全局变量，用来定义模块</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"it works"</span>);</div><div class="line">    &#125;</div><div class="line">    fun1();</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>实现JS文件的异步加载，防止js加载阻塞页面渲染；<br>使用程序调用的方式加载js，防出现众多的script标签；<br>管理模块之间的依赖性，便于代码的编写和维护。<br>但是加载这个文件也会造成网页失去响应，我们可以加上 defer 和 async这个属性。如下：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> &gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>Async属性表明文件需要异步加载，IE不支持这个属性，只支持defer，所以上面把这2个属性都加上。</p><p>在 AMD 中，模块的灵活性主要体现在：</p><ol><li>define 的时候，ID 是可以省略的。</li><li>模块声明和引用依赖，可以通过 Relative ID。</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>require会定义三个变量：define,require,requirejs，其中require === requirejs，一般使用require更简短。<br>define 从名字就可以看出这个api是用来定义一个模块；<br>require 加载依赖模块，并执行加载完后的回调函数。<br>定义模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      alert(<span class="string">"it works"</span>);</div><div class="line">    &#125;</div><div class="line">    fun1();</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>加载模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"js/a"</span>]);</div></pre></td></tr></table></figure><p></p><p>注意require中参数是一个数组，即使只有一个依赖，也必须使用数组来定义<br>requir API的第二个参数是callback，一个function，是用来处理加载完毕后的逻辑，如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"js/a"</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"load finished"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><h2 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h2><p>之前的例子中加载模块都是本地js，但是大部分情况下网页需要加载的JS可能来自本地服务器、其他网站或CDN(内容分发网络)，这样就不能通过这种方式来加载了。<br>以加载一个jquery库为例：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span> : &#123;</div><div class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"js/a"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"load finished"</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>require.config是用来配置模块加载位置，简单点说就是给模块起一个更短更好记的名字，比如将百度的jquery库地址标记为jquery，这样在require时只需要写[“jquery”]就可以加载该js。<br>本地的js我们也可以这样配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span> : &#123;</div><div class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>],</div><div class="line">        <span class="string">"a"</span> : <span class="string">"js/a"</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"a"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"load finished"</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>通过paths的配置会使我们的模块名字更精炼，paths还有一个重要的功能，就是可以配置多个路径，如果远程cdn库没有加载成功，可以加载本地的库，如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span> : &#123;</div><div class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>, <span class="string">"js/jquery"</span>],</div><div class="line">        <span class="string">"a"</span> : <span class="string">"js/a"</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"a"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(<span class="string">"load finished"</span>);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>这样配置后，当百度的jquery没有加载成功后，会加载本地js目录下的jquery。<br>在使用requirejs时，加载模块时不用写.js后缀的，当然也是不能写后缀<br>上面例子中的callback函数中发现有$参数，这个就是依赖的jquery模块的输出变量，如果你依赖多个模块，可以依次写入多个参数来使用：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"jquery"</span>,<span class="string">"underscore"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">$, _</span>)</span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        _.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],alert);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>如果某个模块不输出变量值，则没有，所以尽量将输出的模块写在前面，防止位置错乱引发误解.</p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>上面的例子中重复出现了require.config配置，如果每个页面中都加入配置，必然显得十分不雅，requirejs提供了一种叫”主数据”的功能，我们首先创建一个main.js：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span> : &#123;</div><div class="line">        <span class="string">"jquery"</span> : [<span class="string">"http://libs.baidu.com/jquery/2.0.3/jquery"</span>, <span class="string">"js/jquery"</span>],</div><div class="line">        <span class="string">"a"</span> : <span class="string">"js/a"</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>然后再页面中使用下面的方式来使用requirejs：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">"js/main"</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>解释一下，加载requirejs脚本的script标签加入了data-main属性，这个属性指定的js将在加载完reuqire.js后,继续异步加载data-main属性中的js文件，我们把require.config的配置加入到data-main后，就可以使每一个页面都使用这个配置，然后页面中就可以直接使用require来加载所有的短模块名。</p><p>data-main还有一个重要的功能，当script标签指定data-main属性时，require会默认的将data-main指定的js为根路径，是什么意思呢？如上面的data-main=”js/main”设定后，我们在使用require([‘jquery’])后(不配置jquery的paths)，require会自动加载js/jquery.js这个文件，而不是jquery.js，<br>相当于默认配置了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span> : <span class="string">"js"</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>为requireJS源码已经默认都是以后缀JS文件结尾的。</p><h2 id="自定义模块文件"><a href="#自定义模块文件" class="headerlink" title="自定义模块文件"></a>自定义模块文件</h2><p>RequireJS编写模块不同于其他脚本文件，它良好的使用define来定义一个作用域避免全局空间污染，它可以显示出其依赖关系，并以函数(定义此模块的那个函数)参数的形式将这些依赖进行注入。</p><h3 id="常见的RequireJS目录结构"><a href="#常见的RequireJS目录结构" class="headerlink" title="常见的RequireJS目录结构"></a>常见的RequireJS目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">js</div><div class="line">    app               //一般js文件放到app目录下</div><div class="line">        a.js</div><div class="line">        b.js</div><div class="line">        c.js</div><div class="line">    lib               //一般库文件放在lib目录下</div><div class="line">        jquery.js</div><div class="line">    app.js            // 项目的主文件（入口初始化文件）</div><div class="line">    require.js        //require.js</div><div class="line">index.html</div></pre></td></tr></table></figure><h3 id="b-js内容"><a href="#b-js内容" class="headerlink" title="b.js内容"></a>b.js内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span> : add</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>在app.js里面来调用了b.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'app/b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">b</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(b.add(<span class="number">1</span>,<span class="number">1</span>));</div><div class="line">&#125;);</div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure><p></p><p>加载顺序 requirejs –&gt; app.js –&gt; b.js</p><h3 id="a-js内容"><a href="#a-js内容" class="headerlink" title="a.js内容"></a>a.js内容</h3><p>直接返回一个对象：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">color</span>: <span class="string">"black"</span>,</div><div class="line">        <span class="attr">size</span>: <span class="string">"unisize"</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在app.js里面来调用了a.js<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"app/a"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>全局变量全部使用define函数包围，什么时候需要全局变量的话，直接<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"XX"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">XX</span>)</span>&#123;</div><div class="line">    <span class="comment">//coding</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>这样调用下，同时所有的JS都是异步的，并不会堵塞加载。</p><h2 id="AMD模块规范"><a href="#AMD模块规范" class="headerlink" title="AMD模块规范"></a>AMD模块规范</h2><p>define(id?, dependencies?, factory); 有四种形式：<br>define(factory);<br>define(id, factory);<br>define(dependencies, factory);<br>define(id, dependencies, factory);</p><ul><li>id：路径，不能添加 .js 后缀，命名只能是Top-Level ID，能省则省。</li><li>factory 可以是 Function 或 Object。如果 factory 是 Function，Loader 将在合适的时候执行 factory，并且把返回值作为模块对象；factory 中也可以通过 exports 和 module.exports 暴露对象，前提是 dependencies 显式或隐式(使用默认值)包含 exports 和 module，以及 factory 形参也需要声明它们。<br>dependencies 参数默认值是 [require, exports, module] ，自定义模块名不能重复，参考第五种写法。</li></ul><h3 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">mix</span>: <span class="function"><span class="keyword">function</span>(<span class="params">source, target</span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="第二种写法-有依赖项"><a href="#第二种写法-有依赖项" class="headerlink" title="第二种写法 有依赖项"></a>第二种写法 有依赖项</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'data'</span>, <span class="string">'ui'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">data, ui</span>) </span>&#123;</div><div class="line">    <span class="comment">// init here</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="第三种写法-直接一个对象"><a href="#第三种写法-直接一个对象" class="headerlink" title="第三种写法 直接一个对象"></a>第三种写法 直接一个对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(&#123;</div><div class="line">    <span class="attr">data</span>: [],</div><div class="line">    <span class="attr">ui</span>: []</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="第四种写法-具名模块-如下"><a href="#第四种写法-具名模块-如下" class="headerlink" title="第四种写法 具名模块 如下"></a>第四种写法 具名模块 如下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'index'</span>, [<span class="string">'data'</span>,<span class="string">'base'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">data, base</span>) </span>&#123;</div><div class="line">    <span class="comment">// todo</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>对于第四种写法 具名模块写法我们并不推荐的，因为不书写模块名我们一样可以调用;且在合并代码的时候，我们也可以根据代码自动生成模块名。<br>果我们现在写死了模块名，当某个时候，b.js我要移动到其他目录时候，JS也要跟着改，所以代码维护方面不好，所以不建议书写模块名。</p><h3 id="第五种写法-包装模块"><a href="#第五种写法-包装模块" class="headerlink" title="第五种写法 包装模块"></a>第五种写法 包装模块</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> base = <span class="built_in">require</span>(<span class="string">'base'</span>);</div><div class="line">    exports.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// todo with module base</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>实例：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'app/a'</span>);</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    exports.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// todo with module base</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="built_in">module</span>.exports = &#123;</div><div class="line">        <span class="attr">color</span>: <span class="string">'red'</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 或者</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</div><div class="line">    exports.color = <span class="string">'red'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>书写格式和nodeJS比较像，可以使用require获取模块，使用exports或者module.exports导出API。<br>注意：书写requireJS遵循一个文件一个模块。不要手动写模块名标示。</p><h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="模块的依赖声明"><a href="#模块的依赖声明" class="headerlink" title="模块的依赖声明"></a>模块的依赖声明</h3><p>方式一： 通过 define 的 dependencies 参数声明依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">define(</div><div class="line">    ['conf', 'ui’],</div><div class="line">    function (conf, ui) &#123;</div><div class="line">        function init() &#123;</div><div class="line">            ui.conf(conf);</div><div class="line">            ui.init();</div><div class="line">        &#125;</div><div class="line">        return init;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><p>方式二： 在 factory 中通过 require 声明依赖<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">define(</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> ui = <span class="built_in">require</span>(<span class="string">'ui'</span>);</div><div class="line">            ui.conf(<span class="built_in">require</span>(<span class="string">'conf'</span>));</div><div class="line">            ui.init();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> init;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure><p></p><p>Loader 可以通过正则分析 factory function 的 toString 结果，抽取出依赖的模块，并加载和初始化它们。通过正则分析的原因是，对于一个浏览器端运行的 Loader，内置 AST 分析的功能，其大小和分析效率一定是不可接受的。</p><p>对比：方式二虽然写起来爽，但是性能较差，正则分析需要消耗时间。实践：开发时按方式二写，上线前通过工具打包成方式一。</p><h3 id="依赖划分定义"><a href="#依赖划分定义" class="headerlink" title="依赖划分定义"></a>依赖划分定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'b'</span>);</div><div class="line">    b.init();</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">define(<span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'a'</span>);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            a.foo();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>模块b可以改写为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">require</span>(<span class="string">'a'</span>).foo();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><ul><li>装载时依赖 - 模块在初始化过程就需要用到的依赖模块，我们认为这种依赖是装载时依赖。a 对 b 的依赖就是装载时依赖。</li><li>运行时依赖- 模块在初始化过程不需要用到，但是在后续的运行过程中需要用到的依赖模块，我们认为这种依赖是运行时依赖。b 对 a 的依赖就是运行时依赖。</li></ul><p>结论：模块需要在其装载时依赖都初始化完后再进行初始化，并不是所有的依赖。<br>对于循环依赖，只要依赖环中任何一条边是运行时依赖，这个环理论上就是活的。如果全部边都是装载时依赖，这个环就是死的。</p><h3 id="对于-dependencies-参数中声明的依赖"><a href="#对于-dependencies-参数中声明的依赖" class="headerlink" title="对于 dependencies 参数中声明的依赖"></a>对于 dependencies 参数中声明的依赖</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'a'</span>, [<span class="string">'require'</span>, <span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, b</span>) </span>&#123;</div><div class="line">    b.init();</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">define(<span class="string">'b'</span>, [<span class="string">'require'</span>, <span class="string">'a'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">require</span>(<span class="string">'a'</span>).foo();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>如果 dependencies 里声明，并且 factory 的形参里包含了，则一定是装载时依赖。如果 factory 的形参里未包含，则说明这个依赖有可能是运行时依赖。</p><p>AMD 对于:</p><ol><li>factory 内部 require 的依赖模块</li><li>在 dependencies 中声明但是在 factory 形参列表之外的依赖模块<br>这两种形式声明的依赖，并 没有明确规定执行 factory 初始化的时机。只不过 AMD 玩家通常用 RequireJS，它对于不形成环的依赖模块，都会在自己初始化前先初始化依赖模块。<br>注意：CMD 的 用时定义，确实能让依赖模块初始化的顺序和代码里依赖声明顺序一致。</li></ol><h3 id="require-的形式"><a href="#require-的形式" class="headerlink" title="require 的形式"></a>require 的形式</h3><ol><li>异步 require - require({Array}ids, {Function}callback)：Loader 会负责加载 ids 中的模块，初始化完成，然后调用 callback。调用时传入的参数根据 ids 中声明的模块顺序。</li><li>同步 require - require({string}id)：返回一个现有的模块，如果模块不存在，不允许去请求模块，必须抛出一个错误。</li></ol><h3 id="require-的类型"><a href="#require-的类型" class="headerlink" title="require 的类型"></a>require 的类型</h3><p>在页面中直接使用的 require 是一个全局函数。这就是全局 require<br>在模块的 define 中，通常用到的是局部 require，除非你忘记在 factory 的形参中写 require。<br>区别：局部 require拥有当前所属模块的一些信息，运行的行为受到当前所属模块的影响。所以局部 require可以接受 Relative ID。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'foo/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</div><div class="line">    b.init();</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">define(<span class="string">'foo/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">require</span>(<span class="string">'./a'</span>).foo(); <span class="comment">// 局部的 require 接受 Relative ID</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><h3 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h3><p>Loader 会提供一个配置方法，通常是 require.config。Loader 会用到进行模块查找的配置项有：</p><ul><li>baseUrl</li><li>paths</li><li>packages</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'src'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>通常情况下，模块会根据 ID 到 baseUrl 下寻找。如果模块不在正常的位置，开发者需要配置 paths。如果是 Package，需要配置 packages。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'main'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">main</span>) </span>&#123;</div><div class="line">    main.init();</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>假设 main 模块中声明依赖 ./conf，Loader 需要加载其依赖并完成初始化。但是 ./conf 是一个 Relative ID，Loader 需要将其转换成 Top-Level ID: conf。这个过程我们叫做 normalize。在 normalize 后，Loader 会用 Top-Level ID: conf，根据配置，计算出其地址，然后发起请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'src'</span>,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'bizUI'</span>: <span class="string">'common/ui'</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>require bizUI/TreeView 和 common/ui/TreeView，都会对应到 src/common/ui/TreeView.js 文件。</p><h3 id="打包合并的支持"><a href="#打包合并的支持" class="headerlink" title="打包合并的支持"></a>打包合并的支持</h3><p>开发时正常分文件定义模块，上线前通过工具构建打包，页面上启动应用的代码不需要更改。<br>下面是简单的开发时和打包后代码示例（不同工具打包的代码可能会有细微差别，下面代码仅为说明）。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 开发时 main 模块，src/main.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> conf = <span class="built_in">require</span>(<span class="string">'./conf'</span>);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 开发时 conf 模块，src/conf.js</span></div><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">pageSize</span>: <span class="number">30</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 打包后的 src/main.js</span></div><div class="line">define(<span class="string">'main'</span>, [<span class="string">'require'</span>, <span class="string">'./conf'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> conf = <span class="built_in">require</span>(<span class="string">'./conf'</span>);</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">init</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div><div class="line">define(<span class="string">'conf'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">pageSize</span>: <span class="number">30</span></div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><ol><li>多个 define 可以放在一个 script 中。</li><li>这些 define 的顺序应该没有任何影响。</li></ol><h2 id="requireJS配置项"><a href="#requireJS配置项" class="headerlink" title="requireJS配置项"></a>requireJS配置项</h2><h3 id="baseUrl"><a href="#baseUrl" class="headerlink" title="baseUrl"></a>baseUrl</h3><p>指定本地模块的基准目录，即本地模块的路径是相对于那个目录的，该属性通常有requireJS加载时的data-main属性指定。<br>HTML文件中：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">data-main</span>=<span class="string">"js/app"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>app.js中：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'js/app'</span></div><div class="line">&#125;);</div><div class="line">requirejs([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>由于index.html和js是同一个目录下的，都是放在requireJS文件夹里面的，所以定义baseUrl:’js/app’ 会自动解析成 requireJS/js/app/ 所以requirejs([‘a’,’b’,’c’])的话，会自动到requireJS/js/app/目录下去查找a.js，b.js，c.js.找到了就可以加载出来。</p><p>如果未显示设置baseUrl,则默认值是加载require.js的html所处的位置，如果使用了data-main属性的话，则该路径变成了baseUrl。<br>例如，在HTML文件中：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require.js"</span> <span class="attr">defer</span> <span class="attr">async</span>=<span class="string">"true"</span> <span class="attr">data-main</span>=<span class="string">"js/app"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>在app.js中：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">requirejs([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;</div><div class="line">    <span class="comment">//coding</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>默认情况下是从data-main文件入口去加载js/app.js代码的，但是现在app.js中并没有设置config配置项，所以使用requirejs([‘a’,’b’,’c’],function(a,b,c))的时候会继续加载js下面的a.js,b.js,c.js，如果找到就加载，没有找到就显示404 not found，此例中未找到js/a.js等。</p><h3 id="paths"><a href="#paths" class="headerlink" title="paths"></a>paths</h3><p>paths是映射那些不直接放在baseUrl指定的目录下的文件，设置paths的起始位置是相对于baseUrl的，除非该path设置是以”/”开头或含有URL协议(<a href="http://或者https://" target="_blank" rel="external">http://或者https://</a>).<br>例如在app.js中：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> requirejs.config(&#123;</div><div class="line">   <span class="attr">baseUrl</span>: <span class="string">'js/lib'</span>,</div><div class="line">   <span class="attr">paths</span>: &#123;</div><div class="line">       <span class="attr">app</span>: <span class="string">'../app'</span></div><div class="line">   &#125;</div><div class="line">&#125;);</div><div class="line">requirejs([<span class="string">'app/a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">   <span class="comment">//coding</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>可以看到paths是相对于baseUrl配置项生成的，baseUrl:’js/lib’下的所有js文件，但是paths下的 app:’../app’是相对于js/lib下设置的，’..’的解析到js目录下，然后就解析成js/app下，再require([‘app/a’]),就解析到js/app/a.js了。若注释掉baseUrl: ‘js/lib’，则直接把app/a.js放在项目文件requirejs下了，为requirejs/app/a.js找不到。</p><h3 id="Package"><a href="#Package" class="headerlink" title="Package"></a>Package</h3><p>Package 是独立的同类功能的代码和资源集合，是一种包装方式。</p><ol><li>Package 是需要被独立组织的，甚至是独立开发，模块查找规则需要一些配置支持。相应配置项名称为 location。</li><li>Package 在使用上绝大多数时候需要一个统一的出口（用于内部组织、整体配置、统一暴露等）。相应的配置项名称为 main。</li><li>Package 的名称当然是少不了。相应配置项名称为 name。<br>如：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">packages: [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">name</span>: <span class="string">'dojo'</span>,</div><div class="line">        <span class="attr">location</span>: <span class="string">'dojo/1.7.1'</span>,</div><div class="line">        <span class="attr">main</span>:<span class="string">'main'</span></div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure><p>某个目录下的所有模块，由于可能被跨项目复用，需要抽取成 Package。</p><h3 id="shim参数"><a href="#shim参数" class="headerlink" title="shim参数"></a>shim参数</h3><p>通过require加载的模块一般都需要符合AMD规范即使用define来申明模块，但是部分时候需要加载非AMD规范的js，这时候就需要用到另一个功能：shim。<br>shim解释起来也比较难理解，shim直接翻译为”垫”，其实也是有这层意思的，主要用在两个地方</p><h4 id="非AMD模块输出"><a href="#非AMD模块输出" class="headerlink" title="非AMD模块输出"></a>非AMD模块输出</h4><p>将非标准的AMD模块”垫”成可用的模块，例如：在老版本的jquery中，是没有继承AMD规范的，所以不能直接require[“jquery”],这时候就需要shim。<br>比如我要是用underscore类库，但是它并没有实现AMD规范，那我们可以这样配置<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">shim</span>: &#123;</div><div class="line">        <span class="string">"underscore"</span> : &#123;</div><div class="line">            <span class="attr">exports</span> : <span class="string">"_"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>这样配置后，我们就可以在其他模块中引用underscore模块：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"underscore"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">_</span>)</span>&#123;</div><div class="line">    _.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], alert);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><h4 id="插件形式的非AMD模块"><a href="#插件形式的非AMD模块" class="headerlink" title="插件形式的非AMD模块"></a>插件形式的非AMD模块</h4><p>我们经常会用到jquery插件，而且这些插件基本都不符合AMD规范，比如jquery.form插件，这时候就需要将form插件”垫”到jquery中：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">shim</span>: &#123;</div><div class="line">        <span class="string">"underscore"</span> : &#123;</div><div class="line">            <span class="attr">exports</span> : <span class="string">"_"</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"jquery.form"</span> : &#123;</div><div class="line">            <span class="attr">deps</span> : [<span class="string">"jquery"</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>也可以简写为：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">shim</span>: &#123;</div><div class="line">        <span class="string">"underscore"</span> : &#123;</div><div class="line">            <span class="attr">exports</span> : <span class="string">"_"</span>;</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"jquery.form"</span> : [<span class="string">"jquery"</span>]</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>这样配置之后我们就可以使用加载插件后的jquery了<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config([<span class="string">"jquery"</span>, <span class="string">"jquery.form"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="string">"form"</span>).ajaxSubmit(&#123;...&#125;);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><h4 id="非AMD方式定义的模块"><a href="#非AMD方式定义的模块" class="headerlink" title="非AMD方式定义的模块"></a>非AMD方式定义的模块</h4><p>shim参数解决了使用非AMD方式定义的模块(如jquery插件)及其载入顺序，<br>为那些没有使用define()来声明依赖关系，设置模块的”浏览器全局变量注入”型脚本做依赖和导出配置。<br>在js/app目录下新建文件 depBase.js 代码如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">"a"</span>:<span class="number">11</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>接着在app.js文件里面把代码改成如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'js/lib'</span>,</div><div class="line">    <span class="attr">shim</span>: &#123;</div><div class="line">        <span class="string">'app/depBase'</span>: [<span class="string">'jquery'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="attr">app</span>: <span class="string">'../app'</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'app/depBase'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">base</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(base);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>先加载baseUrl中的配置 js/lib下的jquery文件，然后再加载js/app/depBase.js文件。shim这个参数可以解决没有使用define(function(){})这样的文件包围的代码或者一些全局变量注入，可以确保此文件先加载，然后再加载其他文件。</p><h4 id="不使用shim这个参数"><a href="#不使用shim这个参数" class="headerlink" title="不使用shim这个参数"></a>不使用shim这个参数</h4><p>在最新版的requirejs2.1.15中(以前的版本我不太清楚)，也可以通过require([‘XX’])来解决<br>在js/app文件下新建global.js文件：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">names = ziv; <span class="comment">// 创造一个全局变量names</span></div></pre></td></tr></table></figure><p></p><p>其中js/app/depBase.js代码:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'name'</span>:names</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p></p><p>app.js代码如下初始化如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">baseUrl</span>: <span class="string">'js/app'</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'global'</span>,<span class="string">'depBase'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">global,base</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(base);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>先global初始化引入全局变量names，接着打印出depBase的返回值{name:ziv}。</p><h3 id="Map参数"><a href="#Map参数" class="headerlink" title="Map参数"></a>Map参数</h3><p>Map参数是用来解决同一个模块不同版本的问题，比如在项目开发中，开发初期使用了jquery1.7版本，但是由于业务的需求需要引入jquery1.9以上的版本时候，但是又担心有些是依赖于jquery1.7的代码升级到1.9以上的时候会有问题，因此可以让一部分代码还是依赖于jquery1.7,薪增的代码依赖于jquery1.9.</p><p>lib文件下新增jquery1.7.js和 jquery1.9.1.js，现在在入口文件app.js添加如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">  <span class="attr">map</span>: &#123;</div><div class="line">    <span class="string">'app/a'</span>: &#123;</div><div class="line">      <span class="string">'jquery'</span>: <span class="string">'js/lib/jquery1.7.js'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">'app/b'</span>: &#123;</div><div class="line">      <span class="string">'jquery'</span>: <span class="string">'js/lib/jquery1.9.1.js'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'app/a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">jq</span>)</span>&#123;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'app/b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">jq</span>)</span>&#123;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>然后在app/a.js添加如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>([<span class="string">'jquery'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在app/b.js添加如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>([<span class="string">'jquery'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在app.js中require([‘app/a’],function(jq){ });时候，在加载app/a.js的时候会加载jquery1.7.js文件，在加载app/b.js的时候会加载jquery1.9.1.js。</p><p>如果在app.js中把下面这行b.js代码初始化注释掉require([‘app/b’],function(jq){ });那么就只会加载app/a.js及对应的jquery1.7.js</p><h3 id="config参数"><a href="#config参数" class="headerlink" title="config参数"></a>config参数</h3><p>config是指需要将配置信息传给一个模块，这些配置往往是application级别的信息，需要一个手段将他们向下传递给模块。<br>在requireJS中，基于requirejs.config()的config配置项来实现。要获取这些信息的模块可以加载特殊的依赖 ”moudle” ,并调用module.config().<br>在项目requirejs下js/app文件下新建一个d.js. 然后在app.js初始化文件加入如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    <span class="attr">config</span>: &#123;</div><div class="line">        <span class="string">'app/c'</span>: &#123;</div><div class="line">            <span class="attr">size</span>: <span class="string">'large'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">'app/d'</span>: &#123;</div><div class="line">            <span class="attr">color</span>: <span class="string">'blue'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'app/c'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'app/d'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">dss</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(d);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在c.js里面这样写代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line">    <span class="comment">//其值是'large'</span></div><div class="line">    <span class="keyword">var</span> size = <span class="built_in">module</span>.config().size;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在控制台下运行可以看到能打印出 large值出来，这说明我们可以通过config配置项来给app/c.js传递一个模块信息，比如如上面的一个对象{size：large}，而在c.js里面直接可以通过module.config()方法来获取size的值。<br>下面我们可以使用一个依赖数组来做同样的事情，如下d.js代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'module'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</div><div class="line">  <span class="comment">//Will be the value 'blue'</span></div><div class="line">  <span class="keyword">var</span> color = <span class="built_in">module</span>.config().color;</div><div class="line">  <span class="keyword">return</span> color;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>在控制台看 也一样可以打印出color值出来。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="AMD-设计了插件机制"><a href="#AMD-设计了插件机制" class="headerlink" title="AMD 设计了插件机制"></a>AMD 设计了插件机制</h3><p>一个 Loader Plugin Resource 的形式是， ! 分割两个部分，前面部分是插件模块的 ID，后面部分是资源 ID：<br>[Plugin Module ID]![resource ID]<br>大多数资源的加载需要通过网络，所以可能是异步的。 AMD 要求 Plugin 模块必须包含一个 load 方法。<br>load: function (resourceId, require, load, config)</p><p>通过一个简单的加载 CSS 的 Plugin 模块，可以更容易明白 load 方法的作用。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'css'</span>, &#123;</div><div class="line">    <span class="attr">load</span>: <span class="function"><span class="keyword">function</span> (<span class="params">resourceId, req, load</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>);</div><div class="line">        link.setAttribute(<span class="string">'rel'</span>, <span class="string">'stylesheet'</span>);</div><div class="line">        link.setAttribute(<span class="string">'type'</span>, <span class="string">'text/css'</span>);</div><div class="line">        link.setAttribute(<span class="string">'href'</span>, req.toUrl(resourceId));</div><div class="line">        <span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</div><div class="line">            || <span class="built_in">document</span>.body;</div><div class="line">        parent.appendChild(link);</div><div class="line">        parent = <span class="literal">null</span>;</div><div class="line">        link = <span class="literal">null</span>;</div><div class="line">        load(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><h2 id="requireJS插件"><a href="#requireJS插件" class="headerlink" title="requireJS插件"></a>requireJS插件</h2><p>require.js还提供一系列插件，实现一些特定的功能。<a href="https://github.com/jrburke/requirejs/wiki/Plugins" target="_blank" rel="external">https://github.com/jrburke/requirejs/wiki/Plugins</a><br>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'domready!'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>)</span>&#123;</div><div class="line"> 　<span class="comment">// called once the DOM is ready</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>text和image插件，则是允许require.js加载文本和图片文件。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">　　define([</div><div class="line">　　　　<span class="string">'text!review.txt'</span>,</div><div class="line">　　　　<span class="string">'image!cat.jpg'</span></div><div class="line">　　　　],</div><div class="line">　　　　<span class="function"><span class="keyword">function</span>(<span class="params">review,cat</span>)</span>&#123;</div><div class="line">　　　　　　<span class="built_in">console</span>.log(review);</div><div class="line">　　　　　　<span class="built_in">document</span>.body.appendChild(cat);</div><div class="line">　　　　&#125;</div><div class="line">　　);</div></pre></td></tr></table></figure><p></p><p>类似的插件还有json和mdown，用于加载json文件和markdown文件。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><p>RequireJS加载的每个模块作为script Tag，使用head.appendChild()方法。<br>在模块的定义时，requireJS等到所有的依赖都加载完毕，会为函数的调用计算出正确的顺序，然后在函数中通过正确的顺序进行调用。</p><h3 id="requireJS函数增加了第三个参数errbacks"><a href="#requireJS函数增加了第三个参数errbacks" class="headerlink" title="requireJS函数增加了第三个参数errbacks"></a>requireJS函数增加了第三个参数errbacks</h3><p>在入口文件app.js下增加代码，如下：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'b'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(b);</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    alert(arr);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p></p><p>加载b模块，正常是app/b，这里故意写错，会执行到第二个回调函数进去到alert框。</p><h3 id="在模块载入失败回调中可以使用undef函数移除模块的注册"><a href="#在模块载入失败回调中可以使用undef函数移除模块的注册" class="headerlink" title="在模块载入失败回调中可以使用undef函数移除模块的注册"></a>在模块载入失败回调中可以使用undef函数移除模块的注册</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'b'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">    <span class="comment">//Do something with $ here</span></div><div class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> failedId = err.requireModules &amp;&amp; err.requireModules[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (failedId === <span class="string">'b'</span>) &#123;</div><div class="line">        requirejs.undef(failedId);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>－ 开发时，模块声明不要写 ID<br>－ 模块划分应尽可能细粒度<br>－ 在 factory 中使用 require 引用依赖模块，不要写 dependencies 参数<br>－ 对于要使用的依赖模块，即用即 require：可以有效避免出现死循环依赖；阅读和维护成本低。<br>－ 对于 package 依赖，require 使用 Top-Level ID；对于相同功能模块群组下的依赖，require 使用 Relative ID： var conf = require(‘./conf’);<br>－ 模块的资源引用，在 factory 头部声明<br> － require(‘css!./list.css’);<br> － require(‘tpl!./list.tpl.html’);<br>－ 不要使用 paths：配置了 paths 时不同 ID 的模块可能对应到同一个 define － 文件。在一个系统里，同一个文件对应到多个模块，这种二义很容易导致难以理解的，并且会留下坑。<br>－ 使用第三方库，通过 package 引入：就算所有东西都自己实现，基础的业务无关部分，也应该作为独立的 package。<br>－ package 内部模块对主模块的依赖，不使用 require(‘.’)，使用require(‘main’)<br>－ 可以对环境和模块进行区分，不需要太强迫症，例如jquery，在loader之前引入就ok。<br>－ r.js 是 RequireJS 附带的 optimize 工具，比较成熟，打包构建 AMD 模块的构建产物优秀。<br>－ 因为性能的考虑，线上环境静态资源通过 CDN 分发是一种常用做法。此时，静态资源和页面处于不同的域名下，线上环境的 Loader 配置需要通过 paths，让 Loader 能够正确加载静态资源</p><p>在 AMD 中，模块 ID 与路径应该是一个对应关系。怎么破？这里提供两种玩法：<br>第一种方式：将打包后的模块定义合并文件，直接在页面上通过 script 标签引入。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"amd-loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"combined-md5.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">require</span>([<span class="string">'main'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">main</span>) </span>&#123;</div><div class="line">    main.init();</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>第二种方式：通过 paths 配置映射。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"amd-loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">    <span class="attr">paths</span>: &#123;</div><div class="line">        <span class="string">'main'</span>: <span class="string">'main-file-md5'</span>,</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">require</span>([<span class="string">'main'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">main</span>) </span>&#123;</div><div class="line">    main.init();</div><div class="line">&#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p>在一个 Web 应用，特别是规模较大的 Web 应用中，为了性能最优化的考虑，可能会两种方式结合着玩：</p><ul><li>系统一开始进入就需要的模块，通过第一种方式载入；需要按需加载的模块，通过第二种方式配置</li><li>模块定义合并文件可以根据变更频度打包成多个，充分利用缓存和浏览器的并行下载</li><li>paths 配置项是 id prefix 匹配的，工具处理时注意模块文件同名目录下文件的路径处理</li><li>需要按需加载的模块数量通常不小，根据 DRY 原则，线上环境 paths 配置一定要用工具在构建过程自动完成</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Require.js的问题在于各种参数设置过于繁琐，不容易学习，很难完全掌握。<br>而且，实际应用中，往往还需要在服务器端，将所有模块合并后，再统一加载，这多出了很多工作量。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.requirejs.cn/" target="_blank" rel="external">RequireJS中文网</a><br><a href="http://efe.baidu.com/blog/dissecting-amd-what/" target="_blank" rel="external">玩转AMD - 设计思路</a><br><a href="http://efe.baidu.com/blog/dissecting-amd-how/" target="_blank" rel="external">玩转AMD - 应用实践</a></p><h2 id="本文永久链接"><a href="#本文永久链接" class="headerlink" title="本文永久链接"></a>本文永久链接</h2><p><a href="http://www.yanglonglong.com/blog/2016-06-11-%E4%BD%BF%E7%94%A8RequireJS%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9D%97%E5%8C%96.html" target="_blank" rel="external">使用RequireJS来实现代码模块化</a><br>（完）</p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/JavaScript/" rel="tag">#JavaScript</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2016-06-10-less使用——写给熟悉sass的FEer.html" rel="next" title="less使用——写给熟悉sass的FEer"><i class="fa fa-chevron-left"></i> less使用——写给熟悉sass的FEer</a></div><div class="post-nav-prev post-nav-item"> <a href="/blog/2016-06-20-使用-JavaScript-玩转正则表达式.html" rel="prev" title="使用 JavaScript 玩转正则表达式">使用 JavaScript 玩转正则表达式<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div style="text-align:center;margin-top:15px"> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。<p>作者：<a href="http://www.yanglonglong.com">杨龙龙</a>，订阅：<a href="http://www.yanglonglong.com/rss.xml">RSS</a></p></div><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="http://yanglonglong.com/photos/person/headimg.JPG" alt="杨龙龙"><p class="site-author-name" itemprop="name">杨龙龙</p><p class="site-description motion-element" itemprop="description">前端工程师</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">36</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">20</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/rss.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yllziv" target="_blank" title="github"><i class="fa fa-github"></i> github</a></span><span class="links-of-author-item"><a href="mailto:me@yanglonglong.com" target="_blank" title="邮箱"><i class="fa fa-envelope-o"></i> 邮箱</a></span><span class="links-of-author-item"><a href="https://twitter.com/zivyangll" target="_blank" title="twitter"><i class="fa fa-twitter"></i> twitter</a></span><span class="links-of-author-item"><a href="https://www.douban.com/people/ziv_yll/" target="_blank" title="豆瓣"><i class="fa fa-globe"></i> 豆瓣</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hapyy520/" target="_blank" title="知乎"><i class="fa fa-globe"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://www.instagram.com/yll.ziv/" target="_blank" title="instagram"><i class="fa fa-instagram"></i> instagram</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://blog.liuxj.com/" title="刘宵婧的个人主页" target="_blank">刘宵婧的个人主页</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与传统方式对比"><span class="nav-number">2.</span> <span class="nav-text">与传统方式对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统方式"><span class="nav-number">2.1.</span> <span class="nav-text">传统方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用RequireJS模块加载"><span class="nav-number">2.2.</span> <span class="nav-text">使用RequireJS模块加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-number">3.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载文件"><span class="nav-number">4.</span> <span class="nav-text">加载文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局配置"><span class="nav-number">5.</span> <span class="nav-text">全局配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义模块文件"><span class="nav-number">6.</span> <span class="nav-text">自定义模块文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的RequireJS目录结构"><span class="nav-number">6.1.</span> <span class="nav-text">常见的RequireJS目录结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-js内容"><span class="nav-number">6.2.</span> <span class="nav-text">b.js内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-js内容"><span class="nav-number">6.3.</span> <span class="nav-text">a.js内容</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMD模块规范"><span class="nav-number">7.</span> <span class="nav-text">AMD模块规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种写法"><span class="nav-number">7.1.</span> <span class="nav-text">第一种写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种写法-有依赖项"><span class="nav-number">7.2.</span> <span class="nav-text">第二种写法 有依赖项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三种写法-直接一个对象"><span class="nav-number">7.3.</span> <span class="nav-text">第三种写法 直接一个对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四种写法-具名模块-如下"><span class="nav-number">7.4.</span> <span class="nav-text">第四种写法 具名模块 如下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第五种写法-包装模块"><span class="nav-number">7.5.</span> <span class="nav-text">第五种写法 包装模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">7.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级部分"><span class="nav-number">8.</span> <span class="nav-text">高级部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块的依赖声明"><span class="nav-number">8.1.</span> <span class="nav-text">模块的依赖声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖划分定义"><span class="nav-number">8.2.</span> <span class="nav-text">依赖划分定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于-dependencies-参数中声明的依赖"><span class="nav-number">8.3.</span> <span class="nav-text">对于 dependencies 参数中声明的依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#require-的形式"><span class="nav-number">8.4.</span> <span class="nav-text">require 的形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#require-的类型"><span class="nav-number">8.5.</span> <span class="nav-text">require 的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块查找"><span class="nav-number">8.6.</span> <span class="nav-text">模块查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打包合并的支持"><span class="nav-number">8.7.</span> <span class="nav-text">打包合并的支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#requireJS配置项"><span class="nav-number">9.</span> <span class="nav-text">requireJS配置项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#baseUrl"><span class="nav-number">9.1.</span> <span class="nav-text">baseUrl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#paths"><span class="nav-number">9.2.</span> <span class="nav-text">paths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Package"><span class="nav-number">9.3.</span> <span class="nav-text">Package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shim参数"><span class="nav-number">9.4.</span> <span class="nav-text">shim参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非AMD模块输出"><span class="nav-number">9.4.1.</span> <span class="nav-text">非AMD模块输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插件形式的非AMD模块"><span class="nav-number">9.4.2.</span> <span class="nav-text">插件形式的非AMD模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非AMD方式定义的模块"><span class="nav-number">9.4.3.</span> <span class="nav-text">非AMD方式定义的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不使用shim这个参数"><span class="nav-number">9.4.4.</span> <span class="nav-text">不使用shim这个参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map参数"><span class="nav-number">9.5.</span> <span class="nav-text">Map参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#config参数"><span class="nav-number">9.6.</span> <span class="nav-text">config参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件"><span class="nav-number">10.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AMD-设计了插件机制"><span class="nav-number">10.1.</span> <span class="nav-text">AMD 设计了插件机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#requireJS插件"><span class="nav-number">11.</span> <span class="nav-text">requireJS插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">12.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部机制"><span class="nav-number">12.1.</span> <span class="nav-text">内部机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#requireJS函数增加了第三个参数errbacks"><span class="nav-number">12.2.</span> <span class="nav-text">requireJS函数增加了第三个参数errbacks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在模块载入失败回调中可以使用undef函数移除模块的注册"><span class="nav-number">12.3.</span> <span class="nav-text">在模块载入失败回调中可以使用undef函数移除模块的注册</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建议"><span class="nav-number">13.</span> <span class="nav-text">建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">14.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">15.</span> <span class="nav-text">参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本文永久链接"><span class="nav-number">16.</span> <span class="nav-text">本文永久链接</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2017</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">杨龙龙</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("BmuPD1RNfHPGtYM3h2G54XVc-gzGzoHsz","jO5G91I9DFMgH4TqeBdGXDhE")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var n=0;n<e.length;n++){var i=e[n],r=i.get("url"),l=i.get("time"),s=document.getElementById(r);$(s).find(t).text(l)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e;r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js"></script></body></html>