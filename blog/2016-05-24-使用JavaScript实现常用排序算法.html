<!doctype html><html class="theme-next pisces"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css" rel="stylesheet" type="text/css"><meta name="keywords" content="JavaScript,算法,"><link rel="alternate" href="/rss.xml" title="ziv小站" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"><meta name="description" content="引言在项目中经常使用的算法排序应该是数一数二的，但是js中应用排序的话，一般直接使用数组的sort方法进行排序，虽然扩展性很好（通过回调函数控制顺序），但是对于排序的效率以及针对不同数据使用不同排序方法进行控制的话，还是需要自己研究排序的原理以及适应情况的。对一个随机生成的十万数据的数组，最快的排序能比最慢排序快1000倍甚至更多。 下面介绍的排序算法按照执行速度从慢到快（从简单到复杂）来讲解。"><meta name="keywords" content="JavaScript,算法"><meta property="og:type" content="article"><meta property="og:title" content="使用JavaScript实现常用排序算法"><meta property="og:url" content="http://yanglonglong.com/blog/2016-05-24-使用JavaScript实现常用排序算法.html"><meta property="og:site_name" content="ziv小站"><meta property="og:description" content="引言在项目中经常使用的算法排序应该是数一数二的，但是js中应用排序的话，一般直接使用数组的sort方法进行排序，虽然扩展性很好（通过回调函数控制顺序），但是对于排序的效率以及针对不同数据使用不同排序方法进行控制的话，还是需要自己研究排序的原理以及适应情况的。对一个随机生成的十万数据的数组，最快的排序能比最慢排序快1000倍甚至更多。 下面介绍的排序算法按照执行速度从慢到快（从简单到复杂）来讲解。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2016-05-29T11:27:58.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="使用JavaScript实现常用排序算法"><meta name="twitter:description" content="引言在项目中经常使用的算法排序应该是数一数二的，但是js中应用排序的话，一般直接使用数组的sort方法进行排序，虽然扩展性很好（通过回调函数控制顺序），但是对于排序的效率以及针对不同数据使用不同排序方法进行控制的话，还是需要自己研究排序的原理以及适应情况的。对一个随机生成的十万数据的数组，最快的排序能比最慢排序快1000倍甚至更多。 下面介绍的排序算法按照执行速度从慢到快（从简单到复杂）来讲解。"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!1,duoshuo:{userId:0x56ab38cf59400400,author:"博主"}};!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];"https"===e?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}();var _hmt=_hmt||[];!function(){var t=document.createElement("script");t.src="//hm.baidu.com/hm.js?830d141512282f99a813d8a04a08afde";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><title> 使用JavaScript实现常用排序算法 | ziv小站</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-76641751-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?830d141512282f99a813d8a04a08afde";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ziv小站</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">杨龙龙的个人博客</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-home fa-fw"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-archive fa-fw"></i><br> 归档</a></li><li class="menu-item menu-item-life"><a href="/life" rel="section"><i class="menu-item-icon fa fa-life-ring fa-fw"></i><br> 生活</a></li><li class="menu-item menu-item-photos"><a href="/photos" rel="section"><i class="menu-item-icon fa fa-camera-retro fa-fw"></i><br> 相册</a></li><li class="menu-item menu-item-grid"><a href="/grid" rel="section"><i class="menu-item-icon fa fa-calendar fa-fw"></i><br> 格志</a></li><li class="menu-item menu-item-tool"><a href="/tool" rel="section"><i class="menu-item-icon fa fa-legal fa-fw"></i><br> 工具</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> 使用JavaScript实现常用排序算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-05-24T16:06:59+08:00" content="2016-05-24">2016-05-24</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span></span> <span id="/blog/2016-05-24-使用JavaScript实现常用排序算法.html" class="leancloud_visitors" data-flag-title="使用JavaScript实现常用排序算法">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在项目中经常使用的算法排序应该是数一数二的，但是js中应用排序的话，一般直接使用数组的sort方法进行排序，虽然扩展性很好（通过回调函数控制顺序），但是对于排序的效率以及针对不同数据使用不同排序方法进行控制的话，还是需要自己研究排序的原理以及适应情况的。对一个随机生成的十万数据的数组，最快的排序能比最慢排序快1000倍甚至更多。</p><p>下面介绍的排序算法按照执行速度从慢到快（从简单到复杂）来讲解。</p><p>两个概念：</p><ul><li>稳定排序：基于比较的简单排序算法，即时间复杂度为O(N^2)的排序算法，通常可认为均是稳定排序</li><li>不稳定排序：其它先进的排序算法，比如归并排序、堆排序、桶排序之类（通常这类算法的时间复杂度可优化为n*LogN），通常可认为均是不稳定排序</li></ul><h2 id="预定义几个方法"><a href="#预定义几个方法" class="headerlink" title="预定义几个方法"></a>预定义几个方法</h2><p>首先定义一个全局对象，并在对象中定义几个通用的方法，如交换值、产生随机值数组、输出数组。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> yll = &#123;</div><div class="line">    <span class="comment">// 打印</span></div><div class="line">    log: <span class="function"><span class="keyword">function</span>(<span class="params">content</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(content));</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// 交换两个数组的值</span></div><div class="line">    swap: <span class="function"><span class="keyword">function</span>(<span class="params">array, a, b</span>)</span>&#123;</div><div class="line">        array[a] = [ array[b], array[b]=array[a] ][<span class="number">0</span>];</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">// 获取随机数组</span></div><div class="line">    <span class="comment">// @param n: 数组的长度</span></div><div class="line">    <span class="comment">// @param random：是否是随机值数组</span></div><div class="line">    getArray: <span class="function"><span class="keyword">function</span>(<span class="params">n,random</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> array = [];</div><div class="line">        random = random || <span class="literal">false</span>;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(random) &#123;</div><div class="line">                array.push(<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>))</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                array.push(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p><h2 id="冒泡法排序"><a href="#冒泡法排序" class="headerlink" title="冒泡法排序"></a>冒泡法排序</h2><p>时间复杂度O(n^2)</p><p>思路：临近的数字两两进行比较,按照从小到大或者从大到小的顺序进行交换,这样一趟过去后,最大或最小的数字被交换到了最后一位,然后再从头开始进行两两比较交换,直到倒数第二位时结束。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">yll.bubbleSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i, j;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</div><div class="line">        <span class="comment">//第一次内循环，会确定第一个值是最小值</span></div><div class="line">        <span class="keyword">for</span>(  j = array.length <span class="number">-1</span>; j &gt; i; j--)&#123;</div><div class="line">            <span class="keyword">if</span>(array[j - <span class="number">1</span>] &gt; array[j])&#123;</div><div class="line">                array = yll.swap(array, j<span class="number">-1</span>, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'bubbleSort'</span>);</div><div class="line">yll.bubbleSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'bubbleSort'</span>); <span class="comment">// 5132.042ms</span></div></pre></td></tr></table></figure><p></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度O(n^2)</p><p>思路：每一步都将一个待排数据按其大小插入到已经排序的数据中的适当位置，直到全部插入完毕。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">yll.insertSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i, j, tmp;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">1</span>; i &lt; array.length; i++)&#123;</div><div class="line">        tmp = array[i];</div><div class="line">        <span class="keyword">for</span> ( j = i - <span class="number">1</span>; array[j] &gt; tmp; j--) &#123;</div><div class="line">            array[j + <span class="number">1</span>] = array[j];</div><div class="line">        &#125;</div><div class="line">        array[j + <span class="number">1</span>] = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'insertSort'</span>);</div><div class="line">yll.insertSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'insertSort'</span>); <span class="comment">// 1626.418ms</span></div></pre></td></tr></table></figure><p></p><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>时间复杂度O(n^2)，查找插入位置时使用的是二分查找的方式</p><p>思路</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中二分查找到第一个比它大的数的位置；</li><li>将新元素插入到该位置后；</li><li>重复上述两步。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">yll.binaryInsertionSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">var</span> key = array[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</div><div class="line">            <span class="keyword">var</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</div><div class="line">            <span class="keyword">if</span> (key &lt; array[middle]) &#123;</div><div class="line">                right = middle - <span class="number">1</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                left = middle + <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;</div><div class="line">            array[j + <span class="number">1</span>] = array[j];</div><div class="line">        &#125;</div><div class="line">        array[left] = key;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'binaryInsertionSort'</span>);</div><div class="line">yll.binaryInsertionSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'binaryInsertionSort'</span>); <span class="comment">// 276.426ms</span></div></pre></td></tr></table></figure></li></ol><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>时间复杂度O(n^2)</p><p>思路：找到最小值的下标记下来，再交换，比冒泡法块近10倍。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">yll.selectionSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> i, j, k;</div><div class="line">    <span class="keyword">for</span>( i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</div><div class="line">        k = i;</div><div class="line">        <span class="keyword">for</span>( j = i + <span class="number">1</span>; j &lt; array.length; j++)&#123;</div><div class="line">            <span class="keyword">if</span>(array[j] &lt; array[k])&#123;</div><div class="line">                k = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        array = yll.swap(array, k, i);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'selectionSort'</span>);</div><div class="line">yll.selectionSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'selectionSort'</span>); <span class="comment">// 451.760ms</span></div></pre></td></tr></table></figure><p></p><h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><p>时间复杂度：O(nlogn)</p><p>思路：</p><ol><li>在数据集之中，选择一个元素作为”基准”（pivot）。</li><li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li><li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">yll.quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>);</div><div class="line">　　<span class="keyword">var</span> pivot = array.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</div><div class="line">　　<span class="keyword">var</span> left = [];</div><div class="line">　　<span class="keyword">var</span> right = [];</div><div class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</div><div class="line">　　　　<span class="keyword">if</span> (array[i] &lt; pivot) &#123;</div><div class="line">　　　　　　left.push(array[i]);</div><div class="line">　　　　&#125; <span class="keyword">else</span> &#123;</div><div class="line">　　　　　　right.push(array[i]);</div><div class="line">　　　　&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> yll.quickSort(left).concat(pivot, yll.quickSort(right));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'quickSort'</span>);</div><div class="line">yll.quickSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'quickSort'</span>); <span class="comment">// 129.550ms</span></div></pre></td></tr></table></figure></li></ol><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>时间复杂度：O(nlogn)，跟桶的数量有关系。</p><p>思路：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">yll.bucketSort = <span class="function"><span class="keyword">function</span>(<span class="params">array, num</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> array;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], space, n = <span class="number">0</span>;</div><div class="line">    num = num || <span class="number">100</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">    &#125;</div><div class="line">    space = (max - min + <span class="number">1</span>) / num;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</div><div class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</div><div class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></div><div class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</div><div class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</div><div class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</div><div class="line">                k--;</div><div class="line">            &#125;</div><div class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</div><div class="line">            <span class="comment">//buckets[index] = yll.quickSort(buckets[index]);</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></div><div class="line">            buckets[index] = [];</div><div class="line">            buckets[index].push(array[j]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</div><div class="line">        result = result.concat(buckets[n]);</div><div class="line">        n++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'bucketSort'</span>);</div><div class="line">yll.bucketSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'bucketSort'</span>); <span class="comment">// 12.243ms</span></div></pre></td></tr></table></figure></li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。跟数组中最大值有关系，且只能对整数进行排序。例如[1,1,10000000]会很慢。<br>思路：使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置（确定不大于它的个数）。</p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">yll.countingSort = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="comment">//yll.log(array)</span></div><div class="line">    <span class="keyword">var</span> len = array.length, B = [], C = [], min = max = array[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">        min = min &lt;= array[i] ? min : array[i];</div><div class="line">        max = max &gt;= array[i] ? max : array[i];</div><div class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//yll.log(C);</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = min; j &lt; max; j++) &#123;</div><div class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//yll.log(C);</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k = len - <span class="number">1</span>; k &gt;=<span class="number">0</span>; k--) &#123;</div><div class="line">        <span class="comment">// C[array[k]是array[k]前面的数量(确定位置)，并且包括它自己，所以要减一。</span></div><div class="line">        B[C[array[k]] - <span class="number">1</span>] = array[k];</div><div class="line">        C[array[k]]--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> B;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'countingSort'</span>);</div><div class="line">yll.countingSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'countingSort'</span>); <span class="comment">// 9.729ms</span></div></pre></td></tr></table></figure></li></ol><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基于插入排序，自动选择步长。</p><p>思路：先将整个待排元素序列通过一定的间隔（序列中元素的间隔）分割成若干个子序列 ，对这些小的子序列分别进行直接插入排序，然后依次缩减间隔再进行排序，待整个序列中的元素基本有序（间隔足够小）时，再对全体元素进行一次直接插入排序。在元素基本有序的情况下（接近最好情况），效率是很高的。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">yll.shellSort = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> length = array.length;</div><div class="line">    <span class="keyword">var</span> gap = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (gap &lt; length/<span class="number">3</span>)&#123;</div><div class="line">        gap = (<span class="number">3</span> * gap) + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (gap &gt;= <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i &lt; length; ++i)&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt;= gap &amp;&amp; array[j] &lt; array[j - gap]; j -= gap)&#123;</div><div class="line">                yll.swap(array, j, j - gap);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        gap = (gap - <span class="number">1</span>)/<span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'shellSort'</span>);</div><div class="line">yll.shellSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'shellSort'</span>); <span class="comment">// 15.374ms</span></div></pre></td></tr></table></figure><p></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度 O(nlngn)</p><p>利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>具体算法描述如下：</p><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">yll.heapSort = <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> heapify = <span class="function"><span class="keyword">function</span>(<span class="params">arr, x, len</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> l = <span class="number">2</span> * x, r = <span class="number">2</span> * x + <span class="number">1</span>, largest = x, temp;</div><div class="line">        <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</div><div class="line">            largest = l;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</div><div class="line">            largest = r;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (largest != x) &#123;</div><div class="line">            temp = arr[x];</div><div class="line">            arr[x] = arr[largest];</div><div class="line">            arr[largest] = temp;</div><div class="line">            heapify(arr, largest, len);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//建堆</span></div><div class="line">    <span class="keyword">var</span> heapSize = array.length; <span class="comment">// 堆大小</span></div><div class="line">    <span class="keyword">var</span> temp;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        heapify(array, i, heapSize);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//堆排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</div><div class="line">        temp = array[<span class="number">0</span>];</div><div class="line">        array[<span class="number">0</span>] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">        heapify(array, <span class="number">0</span>, --heapSize);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'heapSort'</span>);</div><div class="line">yll.heapSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>)); </div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'heapSort'</span>); <span class="comment">// 12.785ms</span></div></pre></td></tr></table></figure></li></ol><h2 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>具体算法描述如下：</p><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>递归算法会频繁的调用mergeSort()。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left,right</span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> result=[];</div><div class="line">      <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>)&#123;</div><div class="line">         <span class="keyword">if</span>(left[<span class="number">0</span>] &lt; right[<span class="number">0</span>])&#123;</div><div class="line">             result.push(left.shift());</div><div class="line">         &#125; <span class="keyword">else</span>&#123;</div><div class="line">             result.push(right.shift());</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> result.concat(left).concat(right);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span>(items.length == <span class="number">1</span>)&#123;</div><div class="line">       <span class="keyword">return</span> items;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> middle=<span class="built_in">Math</span>.floor(items.length/<span class="number">2</span>),</div><div class="line">       left=items.slice(<span class="number">0</span>,middle),</div><div class="line">       right=items.slice(middle);</div><div class="line">   <span class="keyword">return</span> merge(mergeSort(left),mergeSort(right));</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'mergeSort'</span>)</div><div class="line">yll.mergeSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>));</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'mergeSort'</span>); <span class="comment">// 62.792ms</span></div></pre></td></tr></table></figure><p></p><h3 id="迭代实现："><a href="#迭代实现：" class="headerlink" title="迭代实现："></a>迭代实现：</h3><p>迭代算法的排序效率比递归慢一点，但不会受调用栈限制的影响。将递归算法改用迭代实现式避免栈溢出错误的方法之一。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">yll.merSort = <span class="function"><span class="keyword">function</span>(<span class="params">items</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left,right</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> result=[];</div><div class="line">        <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(left[<span class="number">0</span>]&lt;right[<span class="number">0</span>])&#123;</div><div class="line">                result.push(left.shift());</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                result.push(right.shift());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result.concat(left).concat(right);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(items.length == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> items;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> work=[];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=items.length;i&lt;len;i++)&#123;</div><div class="line">        work.push([items[i]]);</div><div class="line">    &#125;</div><div class="line">    work.push([]);  <span class="comment">//如果数组长度为奇数</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> lim=len;lim&gt;<span class="number">1</span>;lim=(lim+<span class="number">1</span>)/<span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>,k=<span class="number">0</span>;k&lt;lim;j++,k+=<span class="number">2</span>)&#123;</div><div class="line">            work[j]=merge(work[k],work[k+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">        work[j]=[];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> work[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.time(<span class="string">'mergeSort'</span>)</div><div class="line">yll.merSort(yll.getArray(<span class="number">30000</span>,<span class="literal">true</span>));</div><div class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'mergeSort'</span>); <span class="comment">// 75.594ms</span></div></pre></td></tr></table></figure><p></p><h2 id="本文永久链接"><a href="#本文永久链接" class="headerlink" title="本文永久链接"></a>本文永久链接</h2><p><a href="http://yanglonglong.com/blog/2016-05-24-%E4%BD%BF%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html">使用JavaScript实现常用排序算法</a><br>（完）</p></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/JavaScript/" rel="tag">#JavaScript</a> <a href="/tags/算法/" rel="tag">#算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/2016-05-17-百度前端技术学院任务.html" rel="next" title="百度前端技术学院任务"><i class="fa fa-chevron-left"></i> 百度前端技术学院任务</a></div><div class="post-nav-prev post-nav-item"> <a href="/blog/2016-05-26-使用JavaScript实现顺序检索和二分检索.html" rel="prev" title="使用JavaScript实现顺序检索和二分检索 ">使用JavaScript实现顺序检索和二分检索<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div style="text-align:center;margin-top:15px"> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">知识共享署名-非商业性使用-禁止演绎 3.0 未本地化版本许可协议</a>进行许可。<p>作者：<a href="http://www.yanglonglong.com">杨龙龙</a>，订阅：<a href="http://www.yanglonglong.com/rss.xml">RSS</a></p></div><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="http://yanglonglong.com/photos/person/headimg.JPG" alt="杨龙龙"><p class="site-author-name" itemprop="name">杨龙龙</p><p class="site-description motion-element" itemprop="description">前端工程师</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">36</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">6</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">20</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/rss.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/yllziv" target="_blank" title="github"><i class="fa fa-github"></i> github</a></span><span class="links-of-author-item"><a href="mailto:me@yanglonglong.com" target="_blank" title="邮箱"><i class="fa fa-envelope-o"></i> 邮箱</a></span><span class="links-of-author-item"><a href="https://twitter.com/zivyangll" target="_blank" title="twitter"><i class="fa fa-twitter"></i> twitter</a></span><span class="links-of-author-item"><a href="https://www.douban.com/people/ziv_yll/" target="_blank" title="豆瓣"><i class="fa fa-globe"></i> 豆瓣</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/hapyy520/" target="_blank" title="知乎"><i class="fa fa-globe"></i> 知乎</a></span><span class="links-of-author-item"><a href="https://www.instagram.com/yll.ziv/" target="_blank" title="instagram"><i class="fa fa-instagram"></i> instagram</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://blog.liuxj.com/" title="刘宵婧的个人主页" target="_blank">刘宵婧的个人主页</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义几个方法"><span class="nav-number">2.</span> <span class="nav-text">预定义几个方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡法排序"><span class="nav-number">3.</span> <span class="nav-text">冒泡法排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">4.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分插入排序"><span class="nav-number">5.</span> <span class="nav-text">二分插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">6.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序法"><span class="nav-number">7.</span> <span class="nav-text">快速排序法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序"><span class="nav-number">8.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序"><span class="nav-number">9.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">10.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">11.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#合并排序"><span class="nav-number">12.</span> <span class="nav-text">合并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归算法"><span class="nav-number">12.1.</span> <span class="nav-text">递归算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代实现："><span class="nav-number">12.2.</span> <span class="nav-text">迭代实现：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本文永久链接"><span class="nav-number">13.</span> <span class="nav-text">本文永久链接</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2017</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">杨龙龙</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("BmuPD1RNfHPGtYM3h2G54XVc-gzGzoHsz","jO5G91I9DFMgH4TqeBdGXDhE")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var n=0;n<e.length;n++){var i=e[n],r=i.get("url"),l=i.get("time"),s=document.getElementById(r);$(s).find(t).text(l)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e){var t=$(".leancloud_visitors"),n=t.attr("id").trim(),o=t.attr("data-flag-title").trim(),i=new AV.Query(e);i.equalTo("url",n),i.find({success:function(t){if(t.length>0){var i=t[0];i.fetchWhenSave(!0),i.increment("time"),i.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var r=new e;r.set("title",o),r.set("url",n),r.set("time",1),r.save(null,{success:function(e){var t=$(document.getElementById(n));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):$(".post-title-link").length>1&&showTime(e)})</script><script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js"></script></body></html>